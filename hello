Hello,

I can extract from some data structures a set of grammar rules that looks like:
topLevelRule1 ::= rule1 rule2 rule3
topLevelRule2 ::= rule2
rule1 ::= rule11 rule12
rule11 ~ token11
rule12~ token12
rule2 ~ token2
rule3 ~ token3

.... and so on (any kind of nested structures of this kind are to be expected), 
and I would like to create a Marpa grammar from this to 
parse against some MathML stuff ( and replace subtrees according to it.)

Now the input is not completely described by the grammar, so I would want to 
use some kind of structure like:
Script ::= Notation  (top level rule -> that is what I am going to replace)
      || Presentation (other MathML not described by my grammar)
      || Content (stuff that was already replaced on a previous run or by any other means)
      || Error (anything)

The problem is that the top level rules have precedences that have to be taken into 
account. 

-> I have tried using || to implement that, but found out that its action 
is not deterministic and hence useless for my purpose.

-> I have also tried to use ranking_method in order to implement this,
but it just doesn't work out.

So, my question is as follows - if I have a (potentially large) set of alternative rules with 
certain precedences, how do I define a grammar like that ( also taking into 
account the possibility of ambiguous parses) - so that I can use the "event" adverb 
to actually perform some substitutions. 

To make it clearer  - I would be happy enough even if I only got an answer to how the following 
should be implemented so that the alternative "|| Other action => do_printErr" is ONLY 
executed if the first alternative failed.

:start ::= Script 
Script ::= Number ',' Number action => do_printNr 
          || Other action => do_printErr 
Other ::= Error 
Error ~ [\s\S]*

Number ~ digits
digits ~ [\d]+ 

Thank you in advance for help,
Toloaca Ion


 